/**
 * MEF LSO Sonata
 *  A set of APIs based on the LSO Reference Architecture for Serviceability (Address Validation, Site Queries, Product Offering Qualification) | Quoting | Product Inventory | Ordering | Trouble-ticketing Billing | Contract & Catalog
 *
 * OpenAPI spec version: 3.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.server.apis

// ktor 0.9.x is missing io.ktor.locations.DELETE, this adds it.
// see https://github.com/ktorio/ktor/issues/288

import com.google.gson.Gson
import io.ktor.application.call
import io.ktor.auth.OAuthAccessTokenResponse
import io.ktor.auth.authentication
import io.ktor.auth.oauth
import io.ktor.http.ContentType
import io.ktor.http.HttpStatusCode
import io.ktor.locations.get
import io.ktor.locations.oauthAtLocation
import io.ktor.response.respond
import io.ktor.response.respondText
import io.ktor.routing.Route
import io.ktor.routing.application
import io.ktor.routing.post
import io.ktor.routing.route
import io.swagger.server.ApplicationAuthProviders
import io.swagger.server.ApplicationExecutors
import io.swagger.server.HTTP.client
import io.swagger.server.Paths
import kotlinx.coroutines.experimental.asCoroutineDispatcher

fun Route.CancelProductOrderApi() {
    val gson = Gson()
    val empty = mutableMapOf<String, Any?>()

    route("/productOrderManagement/v3/cancelProductOrder") {
        post {
            val principal = call.authentication.principal<OAuthAccessTokenResponse>()

            if (principal == null) {
                call.respond(HttpStatusCode.Unauthorized)
            } else {
                val exampleContentType = "application/json;charset=utf-8"
                val exampleContentString = """{
                  "requestedCancellationDate" : "2000-01-23T04:56:07.000+00:00",
                  "cancellationReason" : "cancellationReason",
                  "@type" : "@type",
                  "productOrder" : {
                    "@referredType" : "@referredType",
                    "externalId" : "externalId",
                    "href" : "href",
                    "id" : "id",
                    "state" : { },
                    "version" : "version"
                  },
                  "href" : "href",
                  "id" : "id",
                  "state" : { },
                  "@schemaLocation" : "@schemaLocation",
                  "cancellationDeniedReason" : "cancellationDeniedReason"
                }"""

                when (exampleContentType) {
                    "application/json" -> call.respond(gson.fromJson(exampleContentString, empty::class.java))
                    "application/xml" -> call.respondText(exampleContentString, ContentType.Text.Xml)
                    else -> call.respondText(exampleContentString)
                }
            }
        }
    }
            .apply {
                // TODO: ktor doesn't allow different authentication registrations for endpoints sharing the same path but different methods.
                //       It could be the authentication block is being abused here. Until this is resolved, swallow duplicate exceptions.

                try {
                    authentication {
                        oauth(client, ApplicationExecutors.asCoroutineDispatcher(), { ApplicationAuthProviders["bearer"] }, {
                            // TODO: define a callback url here.
                            "/"
                        })
                    }
                } catch (e: io.ktor.application.DuplicateApplicationFeatureException) {
                    application.environment.log.warn("authentication block for '/productOrderManagement/v3/cancelProductOrder' is duplicated in code. " +
                            "Generated endpoints may need to be merged under a 'route' entry.")
                }
            }

    get<Paths.cancelProductOrderFind> { it: Paths.cancelProductOrderFind ->
        val principal = call.authentication.principal<OAuthAccessTokenResponse>()

        if (principal == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            val exampleContentType = "application/json;charset=utf-8"
            val exampleContentString = """[ {
              "requestedCancellationDate" : "2000-01-23T04:56:07.000+00:00",
              "cancellationReason" : "cancellationReason",
              "@type" : "@type",
              "productOrder" : {
                "@referredType" : "@referredType",
                "externalId" : "externalId",
                "href" : "href",
                "id" : "id",
                "state" : { },
                "version" : "version"
              },
              "href" : "href",
              "id" : "id",
              "state" : { },
              "@schemaLocation" : "@schemaLocation",
              "cancellationDeniedReason" : "cancellationDeniedReason"
            }, {
              "requestedCancellationDate" : "2000-01-23T04:56:07.000+00:00",
              "cancellationReason" : "cancellationReason",
              "@type" : "@type",
              "productOrder" : {
                "@referredType" : "@referredType",
                "externalId" : "externalId",
                "href" : "href",
                "id" : "id",
                "state" : { },
                "version" : "version"
              },
              "href" : "href",
              "id" : "id",
              "state" : { },
              "@schemaLocation" : "@schemaLocation",
              "cancellationDeniedReason" : "cancellationDeniedReason"
            } ]"""

            when (exampleContentType) {
                "application/json" -> call.respond(gson.fromJson(exampleContentString, empty::class.java))
                "application/xml" -> call.respondText(exampleContentString, ContentType.Text.Xml)
                else -> call.respondText(exampleContentString)
            }
        }
    }
            .apply {
                // TODO: ktor doesn't allow different authentication registrations for endpoints sharing the same path but different methods.
                //       It could be the authentication block is being abused here. Until this is resolved, swallow duplicate exceptions.

                try {
                    authentication {
                        oauthAtLocation<Paths.cancelProductOrderFind>(client, ApplicationExecutors.asCoroutineDispatcher(),
                                providerLookup = { ApplicationAuthProviders["bearer"] },
                                urlProvider = { currentLocation, provider ->
                                    // TODO: define a callback url here.
                                    "/"
                                })
                    }
                } catch (e: io.ktor.application.DuplicateApplicationFeatureException) {
                    application.environment.log.warn("authentication block for '/productOrderManagement/v3/cancelProductOrder' is duplicated in code. " +
                            "Generated endpoints may need to be merged under a 'route' entry.")
                }
            }

    get<Paths.cancelProductOrderGet> { it: Paths.cancelProductOrderGet ->
        val principal = call.authentication.principal<OAuthAccessTokenResponse>()

        if (principal == null) {
            call.respond(HttpStatusCode.Unauthorized)
        } else {
            val exampleContentType = "application/json;charset=utf-8"
            val exampleContentString = """{
              "requestedCancellationDate" : "2000-01-23T04:56:07.000+00:00",
              "cancellationReason" : "cancellationReason",
              "@type" : "@type",
              "productOrder" : {
                "@referredType" : "@referredType",
                "externalId" : "externalId",
                "href" : "href",
                "id" : "id",
                "state" : { },
                "version" : "version"
              },
              "href" : "href",
              "id" : "id",
              "state" : { },
              "@schemaLocation" : "@schemaLocation",
              "cancellationDeniedReason" : "cancellationDeniedReason"
            }"""

            when (exampleContentType) {
                "application/json" -> call.respond(gson.fromJson(exampleContentString, empty::class.java))
                "application/xml" -> call.respondText(exampleContentString, ContentType.Text.Xml)
                else -> call.respondText(exampleContentString)
            }
        }
    }
            .apply {
                // TODO: ktor doesn't allow different authentication registrations for endpoints sharing the same path but different methods.
                //       It could be the authentication block is being abused here. Until this is resolved, swallow duplicate exceptions.

                try {
                    authentication {
                        oauthAtLocation<Paths.cancelProductOrderGet>(client, ApplicationExecutors.asCoroutineDispatcher(),
                                providerLookup = { ApplicationAuthProviders["bearer"] },
                                urlProvider = { currentLocation, provider ->
                                    // TODO: define a callback url here.
                                    "/"
                                })
                    }
                } catch (e: io.ktor.application.DuplicateApplicationFeatureException) {
                    application.environment.log.warn("authentication block for '/productOrderManagement/v3/cancelProductOrder/{CancelProductOrderId}' is duplicated in code. " +
                            "Generated endpoints may need to be merged under a 'route' entry.")
                }
            }
}
